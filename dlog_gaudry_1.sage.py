
# This file was *autogenerated* from the file dlog_gaudry_1.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_4 = Integer(4); _sage_const_322 = Integer(322); _sage_const_528 = Integer(528); _sage_const_529 = Integer(529); _sage_const_734 = Integer(734); _sage_const_954 = Integer(954); _sage_const_379 = Integer(379); _sage_const_60 = Integer(60); _sage_const_187 = Integer(187); _sage_const_429 = Integer(429); _sage_const_595 = Integer(595); _sage_const_748 = Integer(748); _sage_const_210 = Integer(210); _sage_const_216 = Integer(216); _sage_const_600 = Integer(600); _sage_const_351 = Integer(351); _sage_const_373 = Integer(373); _sage_const_357 = Integer(357); _sage_const_347 = Integer(347); _sage_const_537 = Integer(537); _sage_const_1009 = Integer(1009); _sage_const_145 = Integer(145); _sage_const_636 = Integer(636); _sage_const_634 = Integer(634); _sage_const_656 = Integer(656)
import time
from sage.rings.polynomial.polydict import PolyDict

def elementary_symmetric_polynomials(n, R):
    F = R.base_ring()
    x = list(R.gens())
    e = (n+_sage_const_1 )*[_sage_const_0 ]
    l = monomials(x, n*[_sage_const_2 ])
    l_degree = [y.degree() for y in l]
    for t in l:
        t_degree = t.degree()
        e[t_degree] += t     
    return e

def conversion_to_esp(f, R):
    n = len(R.gens())
    x = list(R.gens())
    e = elementary_symmetric_polynomials(n, R)
    g = _sage_const_0 
    h = f
    while h != _sage_const_0 :
        m = h.lm()
        m_exp = m.exponents()[_sage_const_0 ]
        t1 = h.lc()
        t2 = h.lc()   
        for j in range(n-_sage_const_1 ):
            t1 = t1*(x[j]**(m_exp[j] - m_exp[j+_sage_const_1 ]))
            t2 = t2*(e[j+_sage_const_1 ]**(m_exp[j] - m_exp[j+_sage_const_1 ]))
        t1 = t1*(x[n-_sage_const_1 ]**(m_exp[n-_sage_const_1 ]))
        t2 = t2*(e[n]**(m_exp[n-_sage_const_1 ]))
        g += t1
        h = h - t2  
    return g 

def dict_to_poly(rep, R):
    x = R.gens()
    f = _sage_const_0 
    for t in rep:
        g = _sage_const_1 
        for j in range(len(t)-_sage_const_1 ):
            g = g*(x[j]**t[j])
        g = g*t[-_sage_const_1 ]
        f += g
    return f
def curve(i, n1, n2, A,  B):
    p = next_prime(i)
    Fn = GF(p**n2, 'a')
    F = Fn.extension(n1, 'a1')
    E = EllipticCurve(F, [A, B])
    return [p, E, F]

# this function works for functions defined over multivariate polynomial ring in x, y over a given field.
def weil_descent(f1, F):
    L = F.vector_space()
    R2 = PolynomialRing(F, _sage_const_2 , order = 'lex', names=('x', 'y',)); (x, y,) = R2._first_ngens(2)
    f2 = f1(x, y)
    R3 = PolynomialRing(F, names=('y',)); (y,) = R3._first_ngens(1)
    R4 = PolynomialRing(R3, names=('x',)); (x,) = R4._first_ngens(1)
    f = f2
    print(f.parent())
    cf_x = f.coefficients()
    cf_y = []
    for i in range(len(cf_x)):
        cf_y = cf_y + [cf_x[i].coefficients()]
    alpha = []
    beta = []
    
    for i in range(len(cf_y)):
       for j in range(len(cf_y[i])):
           c = L.coordinates(cf_y[i][j])
           c = [k*x**i*y**j for k in c]
           alpha = alpha + c

    k = _sage_const_0 
    n = F.degree()
    for j in range(n):
        for i in range(len(alpha)/n):
            k = k + alpha[n*i + j]
        beta = beta + [k] 
        k = _sage_const_0  
    return beta

# this function works for any general function defined over multivariate polynomial ring in n variables over a given field.
def weil_descent_1(f, m, F):
    R = PolynomialRing(F, 'x', m, order = 'lex')
    L = F.vector_space()
    f1 = f(R.gens())
    mon_list = f1.monomials()
    coef_list = f1.coefficients()
    alpha = []
    for i in range(len(mon_list)):
        c0 = mon_list[i]
        c1 = coef_list[i]
        c2 = L(c1)
        c2 = [c0*j for j in c2]
        alpha += c2

    beta = []
    k = _sage_const_0 
    n = F.degree()
    for j in range(n):
        for i in range(len(alpha)/n):
            k = k + alpha[n*i + j]
        beta = beta + [k] 
        k = _sage_const_0  
    return beta

def summation_poly(k, R, A, B):
    F = R.base_ring()
    a = F.gens()[_sage_const_0 ]
    x = R.gens()
    S = [_sage_const_1 , x[_sage_const_0 ] - x[_sage_const_1 ]]
    S = S + [(x[_sage_const_0 ] - x[_sage_const_1 ])**_sage_const_2 *x[_sage_const_2 ]**_sage_const_2  - _sage_const_2 *((x[_sage_const_0 ] + x[_sage_const_1 ])*(x[_sage_const_0 ]*x[_sage_const_1 ] + A) + _sage_const_2 *B)*x[_sage_const_2 ] + (x[_sage_const_0 ]*x[_sage_const_1 ] - A)**_sage_const_2  - _sage_const_4 *B*(x[_sage_const_0 ] + x[_sage_const_1 ])]
    S1 = PolynomialRing(R, 'X')
    X = S1.gens()[_sage_const_0 ]
    t1 = list(x) 
    t2 = list(x)
    t1[k-_sage_const_2 ] = X 
    t2 = [x[k-_sage_const_2 ], x[k-_sage_const_1 ], X] + t2[_sage_const_3 :]
    if k==_sage_const_3 :
        return S[k-_sage_const_1 ]
    elif k == _sage_const_4 :
        f_1 = S[_sage_const_2 ](t1)
        f_2 = S[_sage_const_2 ](t2)
        M1 = f_1.sylvester_matrix(f_2, X)
        S = S + [M1.determinant()]
        return S[k-_sage_const_1 ]
    else:
        f = summation_poly(k-_sage_const_1 , R, A, B)
        S = S + [f]
        M = f(t1).sylvester_matrix(S[_sage_const_2 ](t2), X) 
        S = S + [M.determinant()]
    return S[-_sage_const_1 ]

# G = grobner basis of I, I is an ideal over R, we are computing ith elimination ideal(I_i), 
# where I_i = G intersection F[x_i, ..., x_(n-1)]), R = F[x_0, x_1, ..., x_(m-1)], F = GF(p^n).
def elimination_ideal(G, R, i):
    G1 = []
    for j in range(len(G)):
        count = _sage_const_0 
        for k in range(i):
            if G[j].degree(R.gens()[k]) >= _sage_const_1 :
                break
            else:
                count += _sage_const_1 
        if count == i:
            G1 = G1 + [G[j]]
    return G1   

def solve_groebner_basis(S, R):
    solution = []
    n = len(R.gens())
    x = R.gens()
    t = list(x)
    F = R.base_ring()
    a = F.gens()[_sage_const_0 ]
    R1 = F['X']; (X,) = R1._first_ngens(1)
    I = R.ideal(S)
    basis = I.groebner_basis()
    print(basis)
    if _sage_const_1  in basis:
        return solution
    else:    
        J = elimination_ideal(basis, R, n-_sage_const_1 )
        print(J)
        if J == []:
            s = (F.characteristic())**(F.degree())
            if F.degree() == _sage_const_1 :
                solution = [[i*a] for i in range(s)]
            else:
                solution = [[_sage_const_0 ]] + [[a**i] for i in range(s-_sage_const_1 )]        
            print(solution)
        else:
            t[:(n-_sage_const_1 )] = [_sage_const_0 ]*(n-_sage_const_1 )
            t[-_sage_const_1 ] = X
            f = J[_sage_const_0 ](t)    
            roots = [[y[_sage_const_0 ]] for y in f.roots()]
            solution += roots
            print(solution)
        for i in range(n-_sage_const_1 )[::-_sage_const_1 ]:
            if solution == []:
                return solution
                break
            K = elimination_ideal(basis, R, i+_sage_const_1 )
            J = elimination_ideal(basis, R, i)
            # print(J)
            solution1 = []
            if J == K:
                for j in solution:
                    solution1 = [[_sage_const_0 ] + j] + [[a**i] + j for i in range(s-_sage_const_1 )]
            else:        
                for j in solution:
                    l = []
                    for k in J:
                        t1 = list(x)
                        t1[:i] = [_sage_const_0 ]*i
                        t1[i] = X 
                        t1[i+_sage_const_1 :] = j 
                        l += [k(t1)]
                    # print(l)
                    I1 = R1.ideal(l)
                    g = I1.groebner_basis()[_sage_const_0 ]
                    # print(g)
                    if g == _sage_const_1 :
                        break        
                    elif g.roots() == []:
                        break
                    else:    
                        roots = [[y[_sage_const_0 ]] for y in g.roots()]
                        for s in roots:
                            solution1 += [s + j]
                            # print(solution1)
            solution = solution1
            # print(solution)
    return solution      

def factor_base(F, A, B):
    Fn = F.base_ring()
    n2 = Fn.degree()
    p = F.characteristic()
    a = Fn.gens()[_sage_const_0 ]
    factorbase = []
    z = _sage_const_0 
    if F(B).is_square() == _sage_const_1 :
        t = F(B).nth_root(_sage_const_2 )
        P1 = (z, t)
        factorbase += [P1]
    
    if n2 == _sage_const_1 :
        for i in range(p**n2):
            z = i*a
            if F(z**_sage_const_3  + A*z + B).is_square() == _sage_const_1 :
                t = F(z**_sage_const_3  + A*z + B).nth_root(_sage_const_2 )
                P1 = (z, t)
                factorbase += [P1]
    else:
        for i in range(p**n2):
            z = a**i
            if F(z**_sage_const_3  + A*z + B).is_square() == _sage_const_1 :
                t = F(z**_sage_const_3  + A*z + B).nth_root(_sage_const_2 )
                P1 = (z, t)
                factorbase += [P1]           
    return factorbase

# eliptic curve discrete log computation using index calculus algorithm given by Gaudry.
def relations(P, Q, F, A, B):
    count = _sage_const_0  #number of relations
    factorbase = factor_base(F, A, B)
    s = len(factorbase)
    print(s)
    M = matrix(F, s+_sage_const_1 , s)
    a = matrix(F, s+_sage_const_1 , _sage_const_1 )
    b = matrix(F, s+_sage_const_1 , _sage_const_1 )
    E = EllipticCurve(F, [A, B])
    r = E.cardinality()
    print(r)
    Fn = F.base_ring()
    n2 = Fn.degree()
    n1 = F.degree()
    p = F.characteristic()
    a = Fn.gens()[_sage_const_0 ]
    R = PolynomialRing(F, 'x', n1+_sage_const_1 , order = 'lex')
    x = list(R.gens())
    f = summation_poly(n1 + _sage_const_1 , R, A, B)
    while (count < s+_sage_const_1 ):
        u = randrange(r)
        v = randrange(r)
        R = u*E(P) + v*E(Q) 
        t = x[:n1] + [R[_sage_const_0 ]]
        f1 = f(t)
        print(f1)
        f1_esp = conversion_to_esp(f1, R)
        print(f1_esp)
        count = s+_sage_const_1 




#F = F_{q^n2}, q = p^n1(Finite Field) or number field or complex field.    
n1 = _sage_const_4 
#input("insert the degree of the extension field.")
n2 = _sage_const_1 
#input("insert the degree of the extension of the base field.")
p = _sage_const_1009 
F = GF(p**n1, 'a')
a = F.gens()[_sage_const_0 ]
A, B = [_sage_const_529 *a**_sage_const_3  + _sage_const_210 *a**_sage_const_2  + _sage_const_379 *a + _sage_const_351 , _sage_const_636 *a**_sage_const_3  + _sage_const_595 *a**_sage_const_2  + _sage_const_7 *a + _sage_const_216 ]
#input("insert the size of the prime.")
#input("insert the parameters of required elliptic curve.")
P = (_sage_const_748 *a**_sage_const_3  + _sage_const_600 *a**_sage_const_2  + _sage_const_187 *a + _sage_const_357 , _sage_const_322 *a**_sage_const_3  + _sage_const_347 *a**_sage_const_2  + _sage_const_734 *a + _sage_const_656 )
Q = (_sage_const_60 *a**_sage_const_3  + _sage_const_373 *a**_sage_const_2  + _sage_const_429 *a + _sage_const_954 , _sage_const_634 *a**_sage_const_3  + _sage_const_528 *a**_sage_const_2  + _sage_const_537 *a + _sage_const_145 )
relations(P, Q, F, A, B)

#p = 1009, n1 = 4, n2 = 1, A = 529*a^3 + 210*a^2 + 379*a + 351, B = 636*a^3 + 595*a^2 + 7*a + 216, 
#P = (748*a^3 + 600*a^2 + 187*a + 357 : 322*a^3 + 347*a^2 + 734*a + 656 : 1)
#Q = (60*a^3 + 373*a^2 + 429*a + 954 : 634*a^3 + 528*a^2 + 537*a + 145 : 1), Q = a*P, a = 504988480210
















