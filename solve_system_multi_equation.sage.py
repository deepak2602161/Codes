
# This file was *autogenerated* from the file solve_system_multi_equation.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4)# This code is written for SMVP over finite field.
import time
from sage.rings.polynomial.polydict import PolyDict
def elimination_ideal(G, R, i):
    G1 = []
    for j in range(len(G)):
        count = _sage_const_0 
        for k in range(i):
            if G[j].degree(R.gens()[k]) >= _sage_const_1 :
                break
            else:
                count += _sage_const_1 
        if count == i:
            G1 = G1 + [G[j]]
    return G1  

def dict_to_poly(rep, R):
    x = R.gens()
    f = _sage_const_0 
    for t in rep:
        g = _sage_const_1 
        for j in range(len(t)-_sage_const_1 ):
            g = g*(x[j]**t[j])
        g = g*t[-_sage_const_1 ]
        f += g
    return f

def solve_groebner_basis(S, R):
    solution = []
    n = len(R.gens())
    x = R.gens()
    t = list(x)
    F = R.base_ring()
    a = F.gens()[_sage_const_0 ]
    R1 = F['X']; (X,) = R1._first_ngens(1)
    I = R.ideal(S)
    basis = I.groebner_basis()
    print(basis)
    if _sage_const_1  in basis:
        return solution
    else:    
        J = elimination_ideal(basis, R, n-_sage_const_1 )
        print(J)
        if J == []:
            s = (F.characteristic())**(F.degree())
            if F.degree() == _sage_const_1 :
                solution = [[i*a] for i in range(s)]
            else:
                solution = [[_sage_const_0 ]] + [[a**i] for i in range(s-_sage_const_1 )]        
            print(solution)
        else:
            t[:(n-_sage_const_1 )] = [_sage_const_0 ]*(n-_sage_const_1 )
            t[-_sage_const_1 ] = X
            f = J[_sage_const_0 ](t)    
            roots = [[y[_sage_const_0 ]] for y in f.roots()]
            solution += roots
            print(solution)
        for i in range(n-_sage_const_1 )[::-_sage_const_1 ]:
            if solution == []:
                return solution
                break
            K = elimination_ideal(basis, R, i+_sage_const_1 )
            J = elimination_ideal(basis, R, i)
            # print(J)
            solution1 = []
            if J == K:
                for j in solution:
                    solution1 = [[_sage_const_0 ] + j] + [[a**i] + j for i in range(s-_sage_const_1 )]
            else:        
                for j in solution:
                    l = []
                    for k in J:
                        t1 = list(x)
                        t1[:i] = [_sage_const_0 ]*i
                        t1[i] = X 
                        t1[i+_sage_const_1 :] = j 
                        l += [k(t1)]
                    # print(l)
                    I1 = R1.ideal(l)
                    g = I1.groebner_basis()[_sage_const_0 ]
                    # print(g)
                    if g == _sage_const_1 :
                        break        
                    elif g.roots() == []:
                        break
                    else:    
                        roots = [[y[_sage_const_0 ]] for y in g.roots()]
                        for s in roots:
                            solution1 += [s + j]
                            # print(solution1)
            solution = solution1
            # print(solution)
    return solution      

#F = F_{q^n2}, q = p^n1(Finite Field) or number field or complex field.    
n1 = input("insert the degree of the extension field.")
n2 = input("insert the degree of the extension of the base field.")
p = input("insert the characteristic of the base field.")
n = input("number of variables in the polynomial ring.")
Fn = GF(p**n2, 'a')
F = Fn.extension(n2, 'a2')
R = PolynomialRing(F, 'x', n, order = 'lex') 
x = list(R.gens()) 
# S = input("insert system of multivariate polynomials to be solved. input format = [f1(x[0], x[1], ..., x[n-1]), ..., fn(x[0], x[1], ..., x[n-1])]")   
f = dict_to_poly([[_sage_const_5 , _sage_const_0 , _sage_const_0 , _sage_const_1 ], [_sage_const_0 , _sage_const_4 , _sage_const_0 , _sage_const_1 ], [_sage_const_0 , _sage_const_0 , _sage_const_3 , _sage_const_1 ], [_sage_const_0 , _sage_const_0 , _sage_const_0 , -_sage_const_1 ]], R)
g = dict_to_poly([[_sage_const_3 , _sage_const_0 , _sage_const_0 , _sage_const_1 ], [_sage_const_0 , _sage_const_2 , _sage_const_0 , _sage_const_1 ], [_sage_const_0 , _sage_const_0 , _sage_const_2 , _sage_const_1 ], [_sage_const_0 , _sage_const_0 , _sage_const_0 , -_sage_const_1 ]], R)
S = [f, g]
print time.time()
solution = solve_groebner_basis(S, R)
print time.time()
print(len(solution))
print(solution)
sol = []
for j in solution:
    print(j)
    count = _sage_const_0 
    for h in S:
        if h(j) == _sage_const_0 :
            count += _sage_const_1 
    print(count)
    if count == len(S):
        sol += [j]
print(sol)
if sol == solution:
    print("hurray") 
else:
    print("shit")       

