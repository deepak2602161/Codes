
# This file was *autogenerated* from the file solve_system_multi_equation.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)# This code is written for SMVP over finite field.
import time
from sage.rings.polynomial.polydict import PolyDict

def elimination_ideal(G, R, i):
    G1 = []
    for j in range(len(G)):
        count = _sage_const_0 
        for k in range(i):
            if G[j].degree(R.gens()[k]) >= _sage_const_1 :
                break
            else:
                count += _sage_const_1 
        if count == i:
            G1 = G1 + [G[j]]
    return G1  

def dict_to_poly(rep, R):
    x = R.gens()
    f = _sage_const_0 
    for t in rep:
        g = _sage_const_1 
        for j in range(len(t)-_sage_const_1 ):
            g = g*(x[j]**t[j])
        g = g*t[-_sage_const_1 ]
        f += g
    return f

def solve_groebner_basis(S, R):
    solution = []
    n = len(R.gens())
    x = R.gens()
    t = list(x)
    F = R.base_ring()
    a = F.gens()[_sage_const_0 ]
    R1 = F['X']; (X,) = R1._first_ngens(1)
    I = R.ideal(S)
    basis = I.groebner_basis()
    print(basis)
    if _sage_const_1  in basis:
        return solution
    else:    
        J = elimination_ideal(basis, R, n-_sage_const_1 )
        print(J)
        if J == []:
            s = (F.characteristic())**(F.degree())
            if F.degree() == _sage_const_1 :
                solution = [[i*a] for i in range(s)]
            else:
                solution = [[_sage_const_0 ]] + [[a**i] for i in range(s-_sage_const_1 )]        
            print(solution)
        else:
            t[:(n-_sage_const_1 )] = [_sage_const_0 ]*(n-_sage_const_1 )
            t[-_sage_const_1 ] = X
            f = J[_sage_const_0 ](t)    
            roots = [[y[_sage_const_0 ]] for y in f.roots()]
            solution += roots
            print(solution)
        for i in range(n-_sage_const_1 )[::-_sage_const_1 ]:
            if solution == []:
                return solution
                break
            K = elimination_ideal(basis, R, i+_sage_const_1 )
            J = elimination_ideal(basis, R, i)
            # print(J)
            solution1 = []
            if J == K:
                for j in solution:
                    solution1 = [[_sage_const_0 ] + j] + [[a**i] + j for i in range(s-_sage_const_1 )]
            else:        
                for j in solution:
                    l = []
                    for k in J:
                        t1 = list(x)
                        t1[:i] = [_sage_const_0 ]*i
                        t1[i] = X 
                        t1[i+_sage_const_1 :] = j 
                        l += [k(t1)]
                    # print(l)
                    I1 = R1.ideal(l)
                    g = I1.groebner_basis()[_sage_const_0 ]
                    # print(g)
                    if g == _sage_const_1 :
                        break        
                    elif g.roots() == []:
                        break
                    else:    
                        roots = [[y[_sage_const_0 ]] for y in g.roots()]
                        for s in roots:
                            solution1 += [s + j]
                            # print(solution1)
            solution = solution1
            # print(solution)
    return solution      

#F = F_{q^n2}, q = p^n1(Finite Field) or number field or complex field.    
n1 = input("insert the degree of the extension field.")
n2 = input("insert the degree of the extension of the base field.")
p = input("insert the characteristic of the base field.")
n = input("number of variables in the polynomial ring.")
Fn = GF(p**n2, 'a')
F = Fn.extension(n1, 'a2')
R = PolynomialRing(F, 'x', n, order = 'lex') 
x = list(R.gens()) 
S1 = input("insert system of multivariate polynomials to be solved. input format = [[[a_11, a_12, ..., a_1n, c_1], ..., [a_n1, a_n2, ..., a_nn, c_n]], ...,], so f_1(X) = c_1*x^alpha_1, ..., c_n*x^alpha_n, where alpha_i = (a_i1, ..., a_in)")   
S = []
for rep in S1:
    f = dict_to_poly(rep, R)
    S += [f]    
# print time.time()
print(S)
# solution = solve_groebner_basis(S, R)
# print time.time()
# print(len(solution))
# print(solution)

